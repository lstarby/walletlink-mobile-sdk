// Copyright (c) 2018-2019 Coinbase, Inc. <https://coinbase.com/>
// Licensed under the Apache License, version 2.0

package com.coinbase.walletlink.daos

import com.coinbase.wallet.store.interfaces.StoreInterface
import com.coinbase.wallet.store.models.StoreKeys
import com.coinbase.walletlink.extensions.sessions
import com.coinbase.walletlink.models.Session
import io.reactivex.Observable
import java.net.URL
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

class SessionDAO(private val store: StoreInterface) {
    private val accessLock = ReentrantLock()

    /**
     * Get stored sessions
     */
    val sessions: List<Session> get() = getStoredSessions()

    /**
     * Get stored sessions filtered by url
     *
     * @param url URL to filter sessions
     *
     * @return Sessions for given URL
     */
    fun getSessions(url: URL): List<Session> = getStoredSessions().filter { it.url == url }

    /**
     * Get stored session for given sessionID and rpc URL
     *
     * @param id Session ID
     * @param url URL to filter sessions
     *
     * @returns Sessions for given URL
     */
    fun getSession(id: String, url: URL): Session? = getStoredSessions().firstOrNull { it.url == url && it.id == id }

    /**
     * Store session/secret to shared preferences using Android KeyStore
     *
     * @param url WalletLink server websocket URL
     * @param sessionId Session ID generated by the host
     * @param secret Secret generated by the host
     */
    fun save(url: URL, sessionId: String, secret: String) = accessLock.withLock {
        val sessions = (store.get(StoreKeys.sessions) ?: emptyArray())
            .filter { it.id != sessionId && it.url == url }.toMutableList()

        sessions.add(Session(id = sessionId, secret = secret, url = url))

        store.set(StoreKeys.sessions, sessions.toTypedArray())
    }

    /**
     * Deletes sessionID from keychain
     *
     * @param url WalletLink server websocket URL
     * @param sessionId Session ID generated by the host
     */
    fun delete(url: URL, sessionId: String) = accessLock.withLock {
        val sessionIds = (store.get(StoreKeys.sessions) ?: arrayOf())
            .filter { it.id != sessionId && it.url == url }.toMutableList()

        store.set(StoreKeys.sessions, sessionIds.toTypedArray())
    }

    /**
     * Observe for all sessions updates
     *
     * @return [Observable] of all sessions
     */
    fun observeSessions(): Observable<List<Session>> = store.observe(StoreKeys.sessions)
        .map { it.toNullable()?.toList() ?: emptyList() }
        .distinctUntilChanged()

    /**
     * Observe for distinct stored sessionIds update
     *
     * @param url URL to filter sessions
     *
     * @return Session observable for given URL
     */
    fun observeSessions(url: URL): Observable<List<Session>> = store.observe(StoreKeys.sessions)
        .map { list -> list.toNullable()?.filter { it.url == url }?.sortedBy { it.id } ?: emptyList() }
        .distinctUntilChanged()

    // Private helpers

    private fun getStoredSessions(): List<Session> = accessLock
        .withLock { store.get(StoreKeys.sessions)?.toList() ?: listOf() }
        .sortedBy { it.id }
}
